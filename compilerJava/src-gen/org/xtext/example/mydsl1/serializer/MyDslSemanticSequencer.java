/*
 * generated by Xtext 2.13.0-SNAPSHOT
 */
package org.xtext.example.mydsl1.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl1.javaDsl.AbstractMethodDeclaration;
import org.xtext.example.mydsl1.javaDsl.AdditiveExpression;
import org.xtext.example.mydsl1.javaDsl.AndExpression;
import org.xtext.example.mydsl1.javaDsl.ArgumentList;
import org.xtext.example.mydsl1.javaDsl.ArrayAccess;
import org.xtext.example.mydsl1.javaDsl.ArrayCreationExpression;
import org.xtext.example.mydsl1.javaDsl.ArrayExpression;
import org.xtext.example.mydsl1.javaDsl.ArrayInitializer;
import org.xtext.example.mydsl1.javaDsl.Assignment;
import org.xtext.example.mydsl1.javaDsl.Block;
import org.xtext.example.mydsl1.javaDsl.BreakStatement;
import org.xtext.example.mydsl1.javaDsl.CastExpression;
import org.xtext.example.mydsl1.javaDsl.ClassBody;
import org.xtext.example.mydsl1.javaDsl.ClassBodyDeclaration;
import org.xtext.example.mydsl1.javaDsl.ClassDeclaration;
import org.xtext.example.mydsl1.javaDsl.ClassInstanceCreationExpression;
import org.xtext.example.mydsl1.javaDsl.ClassMemberDeclaration;
import org.xtext.example.mydsl1.javaDsl.CompilationUnit;
import org.xtext.example.mydsl1.javaDsl.ConditionalAndExpression;
import org.xtext.example.mydsl1.javaDsl.ConditionalExpression;
import org.xtext.example.mydsl1.javaDsl.ConditionalOrExpression;
import org.xtext.example.mydsl1.javaDsl.ConstantDeclaration;
import org.xtext.example.mydsl1.javaDsl.ConstructorBody;
import org.xtext.example.mydsl1.javaDsl.ConstructorDeclaration;
import org.xtext.example.mydsl1.javaDsl.ConstructorDeclarator;
import org.xtext.example.mydsl1.javaDsl.ContinueStatement;
import org.xtext.example.mydsl1.javaDsl.DoStatement;
import org.xtext.example.mydsl1.javaDsl.EqualityExpression;
import org.xtext.example.mydsl1.javaDsl.Exceptions;
import org.xtext.example.mydsl1.javaDsl.ExclusiveOrExpression;
import org.xtext.example.mydsl1.javaDsl.ExplicitConstructorInvocation;
import org.xtext.example.mydsl1.javaDsl.ExtendsInterfaces;
import org.xtext.example.mydsl1.javaDsl.FieldAccess;
import org.xtext.example.mydsl1.javaDsl.FieldDeclaration;
import org.xtext.example.mydsl1.javaDsl.ForInit;
import org.xtext.example.mydsl1.javaDsl.ForStatement;
import org.xtext.example.mydsl1.javaDsl.ForUpdate;
import org.xtext.example.mydsl1.javaDsl.FormalParameter;
import org.xtext.example.mydsl1.javaDsl.Head;
import org.xtext.example.mydsl1.javaDsl.IfStatement;
import org.xtext.example.mydsl1.javaDsl.ImportStatement;
import org.xtext.example.mydsl1.javaDsl.InclusiveOrExpression;
import org.xtext.example.mydsl1.javaDsl.InterfaceBody;
import org.xtext.example.mydsl1.javaDsl.InterfaceDeclaration;
import org.xtext.example.mydsl1.javaDsl.Interfaces;
import org.xtext.example.mydsl1.javaDsl.JavaDslPackage;
import org.xtext.example.mydsl1.javaDsl.LabeledStatement;
import org.xtext.example.mydsl1.javaDsl.LocalVariableDeclaration;
import org.xtext.example.mydsl1.javaDsl.MethodDeclaration;
import org.xtext.example.mydsl1.javaDsl.MethodDeclarator;
import org.xtext.example.mydsl1.javaDsl.MethodHeader;
import org.xtext.example.mydsl1.javaDsl.MethodInvocation;
import org.xtext.example.mydsl1.javaDsl.MultiplicativeExpression;
import org.xtext.example.mydsl1.javaDsl.NoArrayExpression;
import org.xtext.example.mydsl1.javaDsl.NoArrayExpressionWithoutMinus;
import org.xtext.example.mydsl1.javaDsl.PackageStatement;
import org.xtext.example.mydsl1.javaDsl.PostfixExpression;
import org.xtext.example.mydsl1.javaDsl.PreDecrementExpression;
import org.xtext.example.mydsl1.javaDsl.PreIncrementExpression;
import org.xtext.example.mydsl1.javaDsl.PrimaryNewArray;
import org.xtext.example.mydsl1.javaDsl.PrimaryNoNewArray;
import org.xtext.example.mydsl1.javaDsl.RelationalExpression;
import org.xtext.example.mydsl1.javaDsl.ReturnStatement;
import org.xtext.example.mydsl1.javaDsl.ShiftExpression;
import org.xtext.example.mydsl1.javaDsl.StaticInitializer;
import org.xtext.example.mydsl1.javaDsl.SwitchStatement;
import org.xtext.example.mydsl1.javaDsl.SynchronizedStatement;
import org.xtext.example.mydsl1.javaDsl.ThrowsStatement;
import org.xtext.example.mydsl1.javaDsl.TryStatement;
import org.xtext.example.mydsl1.javaDsl.TypeDeclaration;
import org.xtext.example.mydsl1.javaDsl.VariableDeclarator;
import org.xtext.example.mydsl1.javaDsl.WhileStatement;
import org.xtext.example.mydsl1.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == JavaDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case JavaDslPackage.ABSTRACT_METHOD_DECLARATION:
				sequence_AbstractMethodDeclaration(context, (AbstractMethodDeclaration) semanticObject); 
				return; 
			case JavaDslPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case JavaDslPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case JavaDslPackage.ARGUMENT_LIST:
				sequence_ArgumentList(context, (ArgumentList) semanticObject); 
				return; 
			case JavaDslPackage.ARRAY_ACCESS:
				sequence_ArrayAccess(context, (ArrayAccess) semanticObject); 
				return; 
			case JavaDslPackage.ARRAY_CREATION_EXPRESSION:
				sequence_ArrayCreationExpression(context, (ArrayCreationExpression) semanticObject); 
				return; 
			case JavaDslPackage.ARRAY_EXPRESSION:
				sequence_ArrayExpression(context, (ArrayExpression) semanticObject); 
				return; 
			case JavaDslPackage.ARRAY_INITIALIZER:
				sequence_ArrayInitializer(context, (ArrayInitializer) semanticObject); 
				return; 
			case JavaDslPackage.ASSIGNMENT:
				if (rule == grammarAccess.getVariableInitializerRule()
						|| rule == grammarAccess.getBlockStatementRule()
						|| rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getStatementExpressionRule()
						|| rule == grammarAccess.getConstantExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()) {
					sequence_Assignment(context, (Assignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getPrimaryNoNewArrayRule()) {
					sequence_Assignment_PrimaryNoNewArray(context, (Assignment) semanticObject); 
					return; 
				}
				else break;
			case JavaDslPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case JavaDslPackage.BREAK_STATEMENT:
				sequence_BreakStatement(context, (BreakStatement) semanticObject); 
				return; 
			case JavaDslPackage.CAST_EXPRESSION:
				sequence_CastExpression(context, (CastExpression) semanticObject); 
				return; 
			case JavaDslPackage.CLASS_BODY:
				sequence_ClassBody(context, (ClassBody) semanticObject); 
				return; 
			case JavaDslPackage.CLASS_BODY_DECLARATION:
				sequence_ClassBodyDeclaration(context, (ClassBodyDeclaration) semanticObject); 
				return; 
			case JavaDslPackage.CLASS_DECLARATION:
				sequence_ClassDeclaration(context, (ClassDeclaration) semanticObject); 
				return; 
			case JavaDslPackage.CLASS_INSTANCE_CREATION_EXPRESSION:
				sequence_ClassInstanceCreationExpression(context, (ClassInstanceCreationExpression) semanticObject); 
				return; 
			case JavaDslPackage.CLASS_MEMBER_DECLARATION:
				sequence_ClassMemberDeclaration(context, (ClassMemberDeclaration) semanticObject); 
				return; 
			case JavaDslPackage.COMPILATION_UNIT:
				sequence_CompilationUnit(context, (CompilationUnit) semanticObject); 
				return; 
			case JavaDslPackage.CONDITIONAL_AND_EXPRESSION:
				sequence_ConditionalAndExpression(context, (ConditionalAndExpression) semanticObject); 
				return; 
			case JavaDslPackage.CONDITIONAL_EXPRESSION:
				if (rule == grammarAccess.getVariableInitializerRule()
						|| rule == grammarAccess.getConstantExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentExpressionRule()
						|| rule == grammarAccess.getConditionalExpressionRule()) {
					sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getPrimaryNoNewArrayRule()) {
					sequence_ConditionalExpression_PrimaryNoNewArray(context, (ConditionalExpression) semanticObject); 
					return; 
				}
				else break;
			case JavaDslPackage.CONDITIONAL_OR_EXPRESSION:
				sequence_ConditionalOrExpression(context, (ConditionalOrExpression) semanticObject); 
				return; 
			case JavaDslPackage.CONSTANT_DECLARATION:
				sequence_ConstantDeclaration(context, (ConstantDeclaration) semanticObject); 
				return; 
			case JavaDslPackage.CONSTRUCTOR_BODY:
				sequence_ConstructorBody(context, (ConstructorBody) semanticObject); 
				return; 
			case JavaDslPackage.CONSTRUCTOR_DECLARATION:
				sequence_ConstructorDeclaration(context, (ConstructorDeclaration) semanticObject); 
				return; 
			case JavaDslPackage.CONSTRUCTOR_DECLARATOR:
				sequence_ConstructorDeclarator(context, (ConstructorDeclarator) semanticObject); 
				return; 
			case JavaDslPackage.CONTINUE_STATEMENT:
				sequence_ContinueStatement(context, (ContinueStatement) semanticObject); 
				return; 
			case JavaDslPackage.DO_STATEMENT:
				sequence_DoStatement(context, (DoStatement) semanticObject); 
				return; 
			case JavaDslPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case JavaDslPackage.EXCEPTIONS:
				sequence_Exceptions(context, (Exceptions) semanticObject); 
				return; 
			case JavaDslPackage.EXCLUSIVE_OR_EXPRESSION:
				sequence_ExclusiveOrExpression(context, (ExclusiveOrExpression) semanticObject); 
				return; 
			case JavaDslPackage.EXPLICIT_CONSTRUCTOR_INVOCATION:
				sequence_ExplicitConstructorInvocation(context, (ExplicitConstructorInvocation) semanticObject); 
				return; 
			case JavaDslPackage.EXTENDS_INTERFACES:
				sequence_ExtendsInterfaces(context, (ExtendsInterfaces) semanticObject); 
				return; 
			case JavaDslPackage.FIELD_ACCESS:
				sequence_FieldAccess(context, (FieldAccess) semanticObject); 
				return; 
			case JavaDslPackage.FIELD_DECLARATION:
				sequence_FieldDeclaration(context, (FieldDeclaration) semanticObject); 
				return; 
			case JavaDslPackage.FOR_INIT:
				sequence_ForInit(context, (ForInit) semanticObject); 
				return; 
			case JavaDslPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case JavaDslPackage.FOR_UPDATE:
				sequence_ForUpdate(context, (ForUpdate) semanticObject); 
				return; 
			case JavaDslPackage.FORMAL_PARAMETER:
				sequence_FormalParameter(context, (FormalParameter) semanticObject); 
				return; 
			case JavaDslPackage.HEAD:
				sequence_Head(context, (Head) semanticObject); 
				return; 
			case JavaDslPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case JavaDslPackage.IMPORT_STATEMENT:
				sequence_ImportStatement(context, (ImportStatement) semanticObject); 
				return; 
			case JavaDslPackage.INCLUSIVE_OR_EXPRESSION:
				sequence_InclusiveOrExpression(context, (InclusiveOrExpression) semanticObject); 
				return; 
			case JavaDslPackage.INTERFACE_BODY:
				sequence_InterfaceBody(context, (InterfaceBody) semanticObject); 
				return; 
			case JavaDslPackage.INTERFACE_DECLARATION:
				sequence_InterfaceDeclaration(context, (InterfaceDeclaration) semanticObject); 
				return; 
			case JavaDslPackage.INTERFACES:
				sequence_Interfaces(context, (Interfaces) semanticObject); 
				return; 
			case JavaDslPackage.LABELED_STATEMENT:
				sequence_LabeledStatement(context, (LabeledStatement) semanticObject); 
				return; 
			case JavaDslPackage.LOCAL_VARIABLE_DECLARATION:
				sequence_LocalVariableDeclaration(context, (LocalVariableDeclaration) semanticObject); 
				return; 
			case JavaDslPackage.METHOD_DECLARATION:
				sequence_MethodDeclaration(context, (MethodDeclaration) semanticObject); 
				return; 
			case JavaDslPackage.METHOD_DECLARATOR:
				sequence_MethodDeclarator(context, (MethodDeclarator) semanticObject); 
				return; 
			case JavaDslPackage.METHOD_HEADER:
				sequence_MethodHeader(context, (MethodHeader) semanticObject); 
				return; 
			case JavaDslPackage.METHOD_INVOCATION:
				sequence_MethodInvocation(context, (MethodInvocation) semanticObject); 
				return; 
			case JavaDslPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case JavaDslPackage.NO_ARRAY_EXPRESSION:
				sequence_NoArrayExpression(context, (NoArrayExpression) semanticObject); 
				return; 
			case JavaDslPackage.NO_ARRAY_EXPRESSION_WITHOUT_MINUS:
				sequence_NoArrayExpressionWithoutMinus(context, (NoArrayExpressionWithoutMinus) semanticObject); 
				return; 
			case JavaDslPackage.PACKAGE_STATEMENT:
				sequence_PackageStatement(context, (PackageStatement) semanticObject); 
				return; 
			case JavaDslPackage.POSTFIX_EXPRESSION:
				sequence_PostfixExpression(context, (PostfixExpression) semanticObject); 
				return; 
			case JavaDslPackage.PRE_DECREMENT_EXPRESSION:
				sequence_PreDecrementExpression(context, (PreDecrementExpression) semanticObject); 
				return; 
			case JavaDslPackage.PRE_INCREMENT_EXPRESSION:
				sequence_PreIncrementExpression(context, (PreIncrementExpression) semanticObject); 
				return; 
			case JavaDslPackage.PRIMARY_NEW_ARRAY:
				sequence_PrimaryNewArray(context, (PrimaryNewArray) semanticObject); 
				return; 
			case JavaDslPackage.PRIMARY_NO_NEW_ARRAY:
				sequence_PrimaryNoNewArray(context, (PrimaryNoNewArray) semanticObject); 
				return; 
			case JavaDslPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case JavaDslPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case JavaDslPackage.SHIFT_EXPRESSION:
				sequence_ShiftExpression(context, (ShiftExpression) semanticObject); 
				return; 
			case JavaDslPackage.STATIC_INITIALIZER:
				sequence_StaticInitializer(context, (StaticInitializer) semanticObject); 
				return; 
			case JavaDslPackage.SWITCH_STATEMENT:
				sequence_SwitchStatement(context, (SwitchStatement) semanticObject); 
				return; 
			case JavaDslPackage.SYNCHRONIZED_STATEMENT:
				sequence_SynchronizedStatement(context, (SynchronizedStatement) semanticObject); 
				return; 
			case JavaDslPackage.THROWS_STATEMENT:
				sequence_ThrowsStatement(context, (ThrowsStatement) semanticObject); 
				return; 
			case JavaDslPackage.TRY_STATEMENT:
				sequence_TryStatement(context, (TryStatement) semanticObject); 
				return; 
			case JavaDslPackage.TYPE_DECLARATION:
				sequence_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case JavaDslPackage.VARIABLE_DECLARATOR:
				sequence_VariableDeclarator(context, (VariableDeclarator) semanticObject); 
				return; 
			case JavaDslPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     InterfaceMemberDeclaration returns AbstractMethodDeclaration
	 *     AbstractMethodDeclaration returns AbstractMethodDeclaration
	 *
	 * Constraint:
	 *     (modifiers+=AbstractMethodModifier* returnType=ResultType header=MethodDeclarator throws=Exceptions?)
	 */
	protected void sequence_AbstractMethodDeclaration(ISerializationContext context, AbstractMethodDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveExpression returns AdditiveExpression
	 *
	 * Constraint:
	 *     (operands+=MultiplicativeExpression ((operators+='+' | operators+='-') operands+=MultiplicativeExpression)*)
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, AdditiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression returns AndExpression
	 *
	 * Constraint:
	 *     (operands+=EqualityExpression (operators+='&' operands+=EqualityExpression)*)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArgumentList returns ArgumentList
	 *
	 * Constraint:
	 *     (declarations+=Expression declarations+=Expression*)
	 */
	protected void sequence_ArgumentList(ISerializationContext context, ArgumentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LeftHandSide returns ArrayAccess
	 *     ArrayAccess returns ArrayAccess
	 *
	 * Constraint:
	 *     ((reference=ExpressionName | array=PrimaryNoNewArray) field=ArrayExpression)
	 */
	protected void sequence_ArrayAccess(ISerializationContext context, ArrayAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayCreationExpression returns ArrayCreationExpression
	 *
	 * Constraint:
	 *     ((type=PrimitiveType | type=TypeName) dimensions+=ArrayExpression+ layers+=ArrayType*)
	 */
	protected void sequence_ArrayCreationExpression(ISerializationContext context, ArrayCreationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayExpression returns ArrayExpression
	 *
	 * Constraint:
	 *     index=Expression
	 */
	protected void sequence_ArrayExpression(ISerializationContext context, ArrayExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.ARRAY_EXPRESSION__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.ARRAY_EXPRESSION__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayExpressionAccess().getIndexExpressionParserRuleCall_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableInitializer returns ArrayInitializer
	 *     ArrayInitializer returns ArrayInitializer
	 *
	 * Constraint:
	 *     (values+=VariableInitializer values+=VariableInitializer*)
	 */
	protected void sequence_ArrayInitializer(ISerializationContext context, ArrayInitializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableInitializer returns Assignment
	 *     BlockStatement returns Assignment
	 *     Statement returns Assignment
	 *     StatementExpression returns Assignment
	 *     ConstantExpression returns Assignment
	 *     Expression returns Assignment
	 *     AssignmentExpression returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (object=LeftHandSide operator=AssignmentOperator value=AssignmentExpression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.ASSIGNMENT__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.ASSIGNMENT__OBJECT));
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.ASSIGNMENT__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.ASSIGNMENT__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getObjectLeftHandSideParserRuleCall_0_0(), semanticObject.getObject());
		feeder.accept(grammarAccess.getAssignmentAccess().getOperatorAssignmentOperatorParserRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAssignmentAccess().getValueAssignmentExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns Assignment
	 *     PrimaryNoNewArray returns Assignment
	 *
	 * Constraint:
	 *     (object=LeftHandSide operator=AssignmentOperator value=AssignmentExpression (dimensions+=ArrayExpression? (fields+=ID args+=ArgumentList?)?)+)
	 */
	protected void sequence_Assignment_PrimaryNoNewArray(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *     BlockStatement returns Block
	 *     Statement returns Block
	 *
	 * Constraint:
	 *     declarations+=BlockStatement+
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns BreakStatement
	 *     Statement returns BreakStatement
	 *     BreakStatement returns BreakStatement
	 *
	 * Constraint:
	 *     reference=ID
	 */
	protected void sequence_BreakStatement(ISerializationContext context, BreakStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.BREAK_STATEMENT__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.BREAK_STATEMENT__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBreakStatementAccess().getReferenceIDTerminalRuleCall_1_0(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CastExpression returns CastExpression
	 *     NoArrayExpression returns CastExpression
	 *     NoArrayExpressionWithoutMinus returns CastExpression
	 *
	 * Constraint:
	 *     ((type=PrimitiveType operand=NoArrayExpression) | (type=ReferenceType operand=NoArrayExpressionWithoutMinus))
	 */
	protected void sequence_CastExpression(ISerializationContext context, CastExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassBodyDeclaration returns ClassBodyDeclaration
	 *
	 * Constraint:
	 *     member=ClassMemberDeclaration
	 */
	protected void sequence_ClassBodyDeclaration(ISerializationContext context, ClassBodyDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.CLASS_BODY_DECLARATION__MEMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.CLASS_BODY_DECLARATION__MEMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassBodyDeclarationAccess().getMemberClassMemberDeclarationParserRuleCall_0_0(), semanticObject.getMember());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassBody returns ClassBody
	 *
	 * Constraint:
	 *     declarations+=ClassBodyDeclaration+
	 */
	protected void sequence_ClassBody(ISerializationContext context, ClassBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDeclaration returns ClassDeclaration
	 *
	 * Constraint:
	 *     (modifiers+=ClassModifier* className=ID extend=ClassType? implements=Interfaces? body=ClassBody)
	 */
	protected void sequence_ClassDeclaration(ISerializationContext context, ClassDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ClassInstanceCreationExpression
	 *     Statement returns ClassInstanceCreationExpression
	 *     StatementExpression returns ClassInstanceCreationExpression
	 *     ClassInstanceCreationExpression returns ClassInstanceCreationExpression
	 *
	 * Constraint:
	 *     (type=ClassType args=ArgumentList?)
	 */
	protected void sequence_ClassInstanceCreationExpression(ISerializationContext context, ClassInstanceCreationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassMemberDeclaration returns ClassMemberDeclaration
	 *
	 * Constraint:
	 *     field=FieldDeclaration
	 */
	protected void sequence_ClassMemberDeclaration(ISerializationContext context, ClassMemberDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.CLASS_MEMBER_DECLARATION__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.CLASS_MEMBER_DECLARATION__FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassMemberDeclarationAccess().getFieldFieldDeclarationParserRuleCall_0_0(), semanticObject.getField());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompilationUnit returns CompilationUnit
	 *
	 * Constraint:
	 *     (
	 *         (package=PackageStatement? imports+=ImportStatement+ typeDeclarations+=TypeDeclaration+) | 
	 *         (package=PackageStatement? typeDeclarations+=TypeDeclaration+) | 
	 *         typeDeclarations+=TypeDeclaration+
	 *     )?
	 */
	protected void sequence_CompilationUnit(ISerializationContext context, CompilationUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalAndExpression returns ConditionalAndExpression
	 *
	 * Constraint:
	 *     (operands+=InclusiveOrExpression (operators+='&&' operands+=InclusiveOrExpression)*)
	 */
	protected void sequence_ConditionalAndExpression(ISerializationContext context, ConditionalAndExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableInitializer returns ConditionalExpression
	 *     ConstantExpression returns ConditionalExpression
	 *     Expression returns ConditionalExpression
	 *     AssignmentExpression returns ConditionalExpression
	 *     ConditionalExpression returns ConditionalExpression
	 *
	 * Constraint:
	 *     (condition=ConditionalOrExpression (then=Expression else=ConditionalExpression)?)
	 */
	protected void sequence_ConditionalExpression(ISerializationContext context, ConditionalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns ConditionalExpression
	 *     PrimaryNoNewArray returns ConditionalExpression
	 *
	 * Constraint:
	 *     (
	 *         condition=ConditionalOrExpression 
	 *         (then=Expression else=ConditionalExpression)? 
	 *         (dimensions+=ArrayExpression? (fields+=ID args+=ArgumentList?)?)+
	 *     )
	 */
	protected void sequence_ConditionalExpression_PrimaryNoNewArray(ISerializationContext context, ConditionalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalOrExpression returns ConditionalOrExpression
	 *
	 * Constraint:
	 *     (operands+=ConditionalAndExpression (operators+='||' operands+=ConditionalAndExpression)*)
	 */
	protected void sequence_ConditionalOrExpression(ISerializationContext context, ConditionalOrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceMemberDeclaration returns ConstantDeclaration
	 *     ConstantDeclaration returns ConstantDeclaration
	 *
	 * Constraint:
	 *     (modifiers+=ConstantModifiers* type=Type constant=VariableDeclarator)
	 */
	protected void sequence_ConstantDeclaration(ISerializationContext context, ConstantDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstructorBody returns ConstructorBody
	 *
	 * Constraint:
	 *     ((invocation=ExplicitConstructorInvocation declarations+=BlockStatement+) | declarations+=BlockStatement+)?
	 */
	protected void sequence_ConstructorBody(ISerializationContext context, ConstructorBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassBodyDeclaration returns ConstructorDeclaration
	 *     ConstructorDeclaration returns ConstructorDeclaration
	 *
	 * Constraint:
	 *     (modifiers+=ConstructorModifier* header=ConstructorDeclarator throws=Exceptions? body=ConstructorBody)
	 */
	protected void sequence_ConstructorDeclaration(ISerializationContext context, ConstructorDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstructorDeclarator returns ConstructorDeclarator
	 *
	 * Constraint:
	 *     (name=SimpleTypeName (params+=FormalParameter params+=FormalParameter*)?)
	 */
	protected void sequence_ConstructorDeclarator(ISerializationContext context, ConstructorDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ContinueStatement
	 *     Statement returns ContinueStatement
	 *     ContinueStatement returns ContinueStatement
	 *
	 * Constraint:
	 *     reference=ID
	 */
	protected void sequence_ContinueStatement(ISerializationContext context, ContinueStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.CONTINUE_STATEMENT__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.CONTINUE_STATEMENT__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContinueStatementAccess().getReferenceIDTerminalRuleCall_1_0(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns DoStatement
	 *     Statement returns DoStatement
	 *     DoStatement returns DoStatement
	 *
	 * Constraint:
	 *     (statement=Statement condition?=Expression)
	 */
	protected void sequence_DoStatement(ISerializationContext context, DoStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.DO_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.DO_STATEMENT__STATEMENT));
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.DO_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.DO_STATEMENT__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoStatementAccess().getStatementStatementParserRuleCall_1_0(), semanticObject.getStatement());
		feeder.accept(grammarAccess.getDoStatementAccess().getConditionExpressionParserRuleCall_4_0(), semanticObject.isCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EqualityExpression returns EqualityExpression
	 *
	 * Constraint:
	 *     (operands+=RelationalExpression ((operators+='==' | operators+='!=') operands+=RelationalExpression)*)
	 */
	protected void sequence_EqualityExpression(ISerializationContext context, EqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exceptions returns Exceptions
	 *
	 * Constraint:
	 *     (exceptions+=ClassType exceptions+=ClassType*)
	 */
	protected void sequence_Exceptions(ISerializationContext context, Exceptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExclusiveOrExpression returns ExclusiveOrExpression
	 *
	 * Constraint:
	 *     (operands+=AndExpression (operators+='^' operands+=AndExpression)*)
	 */
	protected void sequence_ExclusiveOrExpression(ISerializationContext context, ExclusiveOrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExplicitConstructorInvocation returns ExplicitConstructorInvocation
	 *
	 * Constraint:
	 *     ((keyword=THIS args=ArgumentList?) | (keyword=SUPER args=ArgumentList?))
	 */
	protected void sequence_ExplicitConstructorInvocation(ISerializationContext context, ExplicitConstructorInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExtendsInterfaces returns ExtendsInterfaces
	 *
	 * Constraint:
	 *     (keyword=EXTENDS interfaces+=InterfaceType interfaces+=InterfaceType*)
	 */
	protected void sequence_ExtendsInterfaces(ISerializationContext context, ExtendsInterfaces semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LeftHandSide returns FieldAccess
	 *     FieldAccess returns FieldAccess
	 *
	 * Constraint:
	 *     ((object=Primary field=ID) | (keyword=SUPER field=ID))
	 */
	protected void sequence_FieldAccess(ISerializationContext context, FieldAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FieldDeclaration returns FieldDeclaration
	 *
	 * Constraint:
	 *     (modifiers+=FieldModifier* type=Type variables+=VariableDeclarator variables+=VariableDeclarator*)
	 */
	protected void sequence_FieldDeclaration(ISerializationContext context, FieldDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForInit returns ForInit
	 *
	 * Constraint:
	 *     ((expressions+=StatementExpression expressions+=StatementExpression*) | localVariable=LocalVariableDeclaration)
	 */
	protected void sequence_ForInit(ISerializationContext context, ForInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ForStatement
	 *     Statement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (initExpr=ForInit? condition?=Expression? updateExpr=ForUpdate? statement=Statement)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForUpdate returns ForUpdate
	 *
	 * Constraint:
	 *     (expressions+=StatementExpression expressions+=StatementExpression*)
	 */
	protected void sequence_ForUpdate(ISerializationContext context, ForUpdate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalParameter returns FormalParameter
	 *
	 * Constraint:
	 *     (type=Type variable=VariableDeclaratorId)
	 */
	protected void sequence_FormalParameter(ISerializationContext context, FormalParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.FORMAL_PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.FORMAL_PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.FORMAL_PARAMETER__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.FORMAL_PARAMETER__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFormalParameterAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFormalParameterAccess().getVariableVariableDeclaratorIdParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Head returns Head
	 *
	 * Constraint:
	 *     program=CompilationUnit
	 */
	protected void sequence_Head(ISerializationContext context, Head semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.HEAD__PROGRAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.HEAD__PROGRAM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHeadAccess().getProgramCompilationUnitParserRuleCall_0(), semanticObject.getProgram());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns IfStatement
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition?=Expression then=Statement else=Statement?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportStatement returns ImportStatement
	 *
	 * Constraint:
	 *     (package=PackageName | object=TypeName)
	 */
	protected void sequence_ImportStatement(ISerializationContext context, ImportStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InclusiveOrExpression returns InclusiveOrExpression
	 *
	 * Constraint:
	 *     (operands+=ExclusiveOrExpression (operators+='|' operands+=ExclusiveOrExpression)*)
	 */
	protected void sequence_InclusiveOrExpression(ISerializationContext context, InclusiveOrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceBody returns InterfaceBody
	 *
	 * Constraint:
	 *     declarations+=InterfaceMemberDeclaration+
	 */
	protected void sequence_InterfaceBody(ISerializationContext context, InterfaceBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceDeclaration returns InterfaceDeclaration
	 *
	 * Constraint:
	 *     (modifiers+=InterfaceModifier* name=ID extends=ExtendsInterfaces? body=InterfaceBody)
	 */
	protected void sequence_InterfaceDeclaration(ISerializationContext context, InterfaceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Interfaces returns Interfaces
	 *
	 * Constraint:
	 *     (keyword=IMPLEMENTS interfaces+=InterfaceType interfaces+=IntegralType*)
	 */
	protected void sequence_Interfaces(ISerializationContext context, Interfaces semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns LabeledStatement
	 *     Statement returns LabeledStatement
	 *     LabeledStatement returns LabeledStatement
	 *
	 * Constraint:
	 *     (label=ID statement=Statement)
	 */
	protected void sequence_LabeledStatement(ISerializationContext context, LabeledStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.LABELED_STATEMENT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.LABELED_STATEMENT__LABEL));
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.LABELED_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.LABELED_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabeledStatementAccess().getLabelIDTerminalRuleCall_0_0(), semanticObject.getLabel());
		feeder.accept(grammarAccess.getLabeledStatementAccess().getStatementStatementParserRuleCall_2_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns LocalVariableDeclaration
	 *     LocalVariableDeclaration returns LocalVariableDeclaration
	 *
	 * Constraint:
	 *     (type=Type variables+=VariableDeclarator variables+=VariableDeclarator*)
	 */
	protected void sequence_LocalVariableDeclaration(ISerializationContext context, LocalVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassMemberDeclaration returns MethodDeclaration
	 *     MethodDeclaration returns MethodDeclaration
	 *
	 * Constraint:
	 *     (signature=MethodHeader body=Block?)
	 */
	protected void sequence_MethodDeclaration(ISerializationContext context, MethodDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodDeclarator returns MethodDeclarator
	 *
	 * Constraint:
	 *     (name=ID (params+=FormalParameter params+=FormalParameter*)?)
	 */
	protected void sequence_MethodDeclarator(ISerializationContext context, MethodDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodHeader returns MethodHeader
	 *
	 * Constraint:
	 *     (modifiers+=MethodModifier* returnType=ResultType header=MethodDeclarator throws=Exceptions?)
	 */
	protected void sequence_MethodHeader(ISerializationContext context, MethodHeader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns MethodInvocation
	 *     Statement returns MethodInvocation
	 *     StatementExpression returns MethodInvocation
	 *     MethodInvocation returns MethodInvocation
	 *
	 * Constraint:
	 *     ((method=MethodName args=ArgumentList?) | (object=Primary method=ID args=ArgumentList?) | (keyword=SUPER method=ID args=ArgumentList?))
	 */
	protected void sequence_MethodInvocation(ISerializationContext context, MethodInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicativeExpression returns MultiplicativeExpression
	 *
	 * Constraint:
	 *     (operands+=NoArrayExpression ((operators+='*' | operators+='/' | operators+='%') operands+=NoArrayExpression)*)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, MultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoArrayExpression returns NoArrayExpressionWithoutMinus
	 *     NoArrayExpressionWithoutMinus returns NoArrayExpressionWithoutMinus
	 *
	 * Constraint:
	 *     ((operator='~' operand=NoArrayExpression) | (operator='!' operand=NoArrayExpression))
	 */
	protected void sequence_NoArrayExpressionWithoutMinus(ISerializationContext context, NoArrayExpressionWithoutMinus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NoArrayExpression returns NoArrayExpression
	 *
	 * Constraint:
	 *     ((operator='+' operand=NoArrayExpression) | (operator='-' operand=NoArrayExpression))
	 */
	protected void sequence_NoArrayExpression(ISerializationContext context, NoArrayExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageStatement returns PackageStatement
	 *
	 * Constraint:
	 *     name=PackageName
	 */
	protected void sequence_PackageStatement(ISerializationContext context, PackageStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.PACKAGE_STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.PACKAGE_STATEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackageStatementAccess().getNamePackageNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns PostfixExpression
	 *     Statement returns PostfixExpression
	 *     StatementExpression returns PostfixExpression
	 *     NoArrayExpression returns PostfixExpression
	 *     NoArrayExpressionWithoutMinus returns PostfixExpression
	 *     PostfixExpression returns PostfixExpression
	 *
	 * Constraint:
	 *     ((object=Primary | reference=ExpressionName) operators+='--'? (operators+='++'? operators+='--'?)*)
	 */
	protected void sequence_PostfixExpression(ISerializationContext context, PostfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns PreDecrementExpression
	 *     Statement returns PreDecrementExpression
	 *     StatementExpression returns PreDecrementExpression
	 *     NoArrayExpression returns PreDecrementExpression
	 *     PreDecrementExpression returns PreDecrementExpression
	 *
	 * Constraint:
	 *     (operator='--' operand=NoArrayExpression)
	 */
	protected void sequence_PreDecrementExpression(ISerializationContext context, PreDecrementExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.NO_ARRAY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.NO_ARRAY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.NO_ARRAY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.NO_ARRAY_EXPRESSION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreDecrementExpressionAccess().getOperatorHyphenMinusHyphenMinusKeyword_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getPreDecrementExpressionAccess().getOperandNoArrayExpressionParserRuleCall_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns PreIncrementExpression
	 *     Statement returns PreIncrementExpression
	 *     StatementExpression returns PreIncrementExpression
	 *     NoArrayExpression returns PreIncrementExpression
	 *     PreIncrementExpression returns PreIncrementExpression
	 *
	 * Constraint:
	 *     (operator='++' operand=NoArrayExpression)
	 */
	protected void sequence_PreIncrementExpression(ISerializationContext context, PreIncrementExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.NO_ARRAY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.NO_ARRAY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.NO_ARRAY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.NO_ARRAY_EXPRESSION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreIncrementExpressionAccess().getOperatorPlusSignPlusSignKeyword_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getPreIncrementExpressionAccess().getOperandNoArrayExpressionParserRuleCall_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns PrimaryNewArray
	 *     PrimaryNewArray returns PrimaryNewArray
	 *
	 * Constraint:
	 *     (array=ArrayCreationExpression (dimensions+=ArrayExpression? (fields+=ID args+=ArgumentList?)?)+)
	 */
	protected void sequence_PrimaryNewArray(ISerializationContext context, PrimaryNewArray semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns PrimaryNoNewArray
	 *     PrimaryNoNewArray returns PrimaryNoNewArray
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             literal=Literal | 
	 *             keyword=THIS | 
	 *             class=ClassInstanceCreationExpression | 
	 *             keyword=SUPER | 
	 *             (method=MethodName args+=ArgumentList?) | 
	 *             (reference=ExpressionName dimensions+=ArrayExpression)
	 *         ) 
	 *         (dimensions+=ArrayExpression? (fields+=ID args+=ArgumentList?)?)+
	 *     )
	 */
	protected void sequence_PrimaryNoNewArray(ISerializationContext context, PrimaryNoNewArray semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationalExpression returns RelationalExpression
	 *
	 * Constraint:
	 *     (
	 *         operands+=ShiftExpression 
	 *         (
	 *             ((operators+='<' | operators+='>' | operators+='<=' | operators+='>=') operands+=ShiftExpression) | 
	 *             (operators+=INSTANCEOF classes+=ReferenceType)
	 *         )*
	 *     )
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, RelationalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ReturnStatement
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.RETURN_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.RETURN_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnStatementAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ShiftExpression returns ShiftExpression
	 *
	 * Constraint:
	 *     (operands+=AdditiveExpression ((operators+='<<' | operators+='>>' | operators+='>>>') operands+=AdditiveExpression)*)
	 */
	protected void sequence_ShiftExpression(ISerializationContext context, ShiftExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassBodyDeclaration returns StaticInitializer
	 *     StaticInitializer returns StaticInitializer
	 *
	 * Constraint:
	 *     code=Block
	 */
	protected void sequence_StaticInitializer(ISerializationContext context, StaticInitializer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.STATIC_INITIALIZER__CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.STATIC_INITIALIZER__CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStaticInitializerAccess().getCodeBlockParserRuleCall_1_0(), semanticObject.getCode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns SwitchStatement
	 *     Statement returns SwitchStatement
	 *     SwitchStatement returns SwitchStatement
	 *
	 * Constraint:
	 *     (expression=Expression (constants+=ConstantExpression | statements+=BlockStatement)*)
	 */
	protected void sequence_SwitchStatement(ISerializationContext context, SwitchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns SynchronizedStatement
	 *     Statement returns SynchronizedStatement
	 *     SynchronizedStatement returns SynchronizedStatement
	 *
	 * Constraint:
	 *     (expression=Expression body=Block)
	 */
	protected void sequence_SynchronizedStatement(ISerializationContext context, SynchronizedStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.SYNCHRONIZED_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.SYNCHRONIZED_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.SYNCHRONIZED_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.SYNCHRONIZED_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSynchronizedStatementAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSynchronizedStatementAccess().getBodyBlockParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ThrowsStatement
	 *     Statement returns ThrowsStatement
	 *     ThrowsStatement returns ThrowsStatement
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ThrowsStatement(ISerializationContext context, ThrowsStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.THROWS_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.THROWS_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThrowsStatementAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns TryStatement
	 *     Statement returns TryStatement
	 *     TryStatement returns TryStatement
	 *
	 * Constraint:
	 *     (tryBody=Block (params+=FormalParameter catchesBody+=Block)* finallyBody=Block?)
	 */
	protected void sequence_TryStatement(ISerializationContext context, TryStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns TypeDeclaration
	 *
	 * Constraint:
	 *     (doc=DOC_COMMENT? (name=ClassDeclaration | name=InterfaceDeclaration))
	 */
	protected void sequence_TypeDeclaration(ISerializationContext context, TypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarator returns VariableDeclarator
	 *
	 * Constraint:
	 *     (name=VariableDeclaratorId value=VariableInitializer?)
	 */
	protected void sequence_VariableDeclarator(ISerializationContext context, VariableDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns WhileStatement
	 *     Statement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition?=Expression statement=Statement)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.WHILE_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.WHILE_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, JavaDslPackage.Literals.WHILE_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavaDslPackage.Literals.WHILE_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.isCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getStatementStatementParserRuleCall_4_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
}
